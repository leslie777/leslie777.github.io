---
layout: post
title:  "java基础"
categories: Java
tags:  Java 继承 多态 线程 io 接口
excerpt: 再次学习java 基础
---

* content
{:toc}

---

## 继承

#### 继承的定义和作用
##### 继承的定义
继承是从已有的类中派生出新的类，新的类能吸收已有的类的数据属性和行为，并能扩展新的能力，已有的类为父类或者叫基类，被派生出来的类为子类或叫超类。
##### 继承的作用
**1.** 通过继承已有的类，实现代码的复用。

**2.** 很容易修改或者扩展已有的类的方法属性。
##### 继承的实现
Java 中继承是通过extends关键字来实现的。其基本声明格式如下:

[修饰符] class 子类名 extends 父类名{

    类体
}

###### 实现继承语法参数说明
**修饰符**： 可选参数，用于指定类的访问权，可选值为public,abstract,final。

**子类名**：必选参数

**extends 父类名**:必选参数，用于指定要定义的子类继承哪个父类。

#### 继承的访问控制

|            |  private   |  default  |  protected | public   |
| -----------|:----------:|:---------:|:----------:|:--------:|
| 同一个类中 |     Y      |    Y      |      Y     |    Y     |
| 同一个包中 |            |    Y      |      Y     |    Y     |
| 子类中     |            |           |      Y     |    Y     |
|全局范围内  |            |           |            |    Y     |


#### this & super

##### this 的使用

Java中this当前类的引用，在创建类时，编译器会自动为创建的类关联一个对应的引用，使用this,可以调用该类的所有成员变量与方法，下面是this的使用:

###### 1.在构造器中调用构造器

有时候会在一个构造函数中调用另一个构造函数，为了避免写重复的代码，我们可以在某个构造器中使用this调用另一个带有参数构造器，但this必须是某个构造器第一行代码。
###### 2.使用this 调用类中的成员变量
有时候类中的成员方法中为类的成员变量赋值，但是方法中的形参参名与类中的成员变量名相同时，可以用this关键字指名调用类中的成员变量。
###### 3.返回this 引用
有时候想获得当前类的引用，可以在某个方法中返回this引用。

**注意**：静态方法中不存在this引用。

**例**：
public class AnyThing {

	public static int count = 0;
	private String name;
	
	public void setName(String name){
		this.name = name;    //使用this指明调用当前类的成员变量
	}
	
	public AnyThing getacurrentThis(){
		return this;    // 返回当前类的this引用
	}
	public AnyThing(){
		
		this("调用有参构造方法");   // 使用this调用有参的构造函数
	
		System.out.println("无参的构造方法");
	}
	
	public void printName(){
		System.out.println(name);
	}
	
	public AnyThing(String name){
		System.out.println("有参的构造函数");
	}
	public static void main(String[] args) {
	
		 AnyThing anyThing = new AnyThing();
		 anyThing.setName("JAVA");
		 AnyThing at = anyThing.getacurrentThis();
		 at.printName();	
	}
}

运行结果：

有参的构造函数

无参的构造方法

JAVA

##### super 的使用

子类可以继承父类的非私有成员变量和方法作为自己的成员变量或者方法。但是父类声明的成员变量与子类声明的成员变量同名时，此时子类的成员变量隐藏了父类的成员变量。若子类声明的方法覆盖了父类的方法时，该父类的方法被隐藏。所以使用super关键字可以调用父类隐藏的变量或者方法。因此super有以上几种使用方法:

###### 1.调用父类的构造方法
子类可以调用父类的构造函数，但必须在子类的构造函数中使用super关键字调用父类的构造函数。调用父类的语法格式如下：

super([参数列表]);

###### 2. 操作被隐藏的成员变量和被重写的成员方法
在子类中操作父类中隐藏的成员变量和重写的成员方法，可以使用关键字super,语法格式如下：

super.成员变量名

super.成员方法名([参数列表])

**例：**

public class Base {

	private String name;
	public int i = 6;
	
	public Base(String name){
		this.name = name;
	}
	
	public void fun(){
		
		System.out.println("Base print()");
		
	}
	
}

public class ExtendBase extends Base{
	
	public int i = 8;
	public ExtendBase(String name) {
		super(name);n      //调用父类的构造函数
	}

	public void print(){
		
		System.out.println("调用父类中隐藏的变量 i="+super.i);n  //调用父类中隐藏的变量
		super.fun();        //调用父类隐藏的方法fun()
	}
	
	public void fun(){
		
		System.out.println("ExtendBase print()");
	}
	public static void main(String[] args) {
		
		new ExtendBase("JAVA").print();
	}

}

运行结果:

调用父类中隐藏的变量 i=6

Base print()

#### 继承与组合的区别

继承是实现类重用的重要手段，但继承带来最大坏处是破坏封装。相比之下，组合也是实现类重组的重要手段，但它能使提供很好的封装性。

组合和继承都允许在新的类中放置对象，组合是显示的，继承是隐式的。

有时间作为开发一个程序，需要扩展一个类时，首先组合，技术需要时就选择继承。或则二者结合。

## 接口

####  接口的定义和作用
##### 接口的定义
使用interface来定义一个接口。接口定义与类的定义类似，也分为接口的声明和接口体，其中接口体由变量定义和方法定义两部分组成。定义接口的基本语法格式如下:

[修饰符] interface 接口名[extends 父接口名列表]{

    
    [public][static][final] 变量;
        
    [public][abstract] 方法;
}

###### 实现接口的语法格式参数说明
**修饰符**：可选参数，用于指定类的访问权限，可选值为public，若省略为默认的访问权限

**接口名**：必选

**extends 父接口名**：可选

**方法**：接口中的方法只有定义没有被实现

例：

public interface Service {
	
	void method1();
	void method2();
	
}


##### 接口的作用

接口只是定义了一种规范，只定义了某一批类所要遵守的规范，接口并不关心这些类的内部状态数据，也不关心这些类里方法的实现细节，它规定这批类必须提供某些方法，提供这些方法的类就可满足实际需要。
所以接口的作用一是使代码的复用性很好，作用二是可以解决java不能实现多继承的弊端，作用三是实现多态。
例：

 public interface Shape {
 
	void draw();
}

public class Circle implements Shape {

	public void draw() {
		
		System.out.println("圆形");
		
	}
}

public class Square implements Shape {

	public void draw() {
	
		System.out.println("正方形");

	}
}

public class Trigon implements Shape {

	public void draw() {
		
		System.out.println("三角形");
	}
}

public class Main {

	public static void main(String[] args) {
	
		ArrayList<Shape> array = new ArrayList<Shape>();
		array.add(new Trigon());
		array.add(new Square());
		array.add(new Circle());
		for(Shape shape : array)
			shape.draw();
	}
}


输出结果:

三角形

正方形

圆形

##### 接口的实现
接口定义后可以在类中实现，在要实现接口的类后面加上关键字，基本语法格式如下:
[修饰符] class <类名> [extends 父类名] implements 接口列表 {
    
}

###### 定义接口的语法格式参数说明
修饰符： 可选，可选值有public,省略默认的访问权限。

接口名：必选

extends 父类名 可选

方法：接口中方法只有被定义，没有被实现。

例：

public class Implementation1 implements Service {

	@Override
	public void method1() {
		
		System.out.println("Implementation1 method1");
		
	}

	@Override
	public void method2() {
		
		System.out.println("Implementation1 method2");
	}

	

}

###### 接口中的域
接口的任何域都自动是staic和final的。

在接口中的域不可以是“空final",但可以被非常量表达式初始化。

接口可以嵌套,当一个接口是public域时，那么嵌套接口自动是public,并且接口内其它元素也是public。

创建接口时若没有用public修饰时，那么该接口默认是包作用域，因此该类只能用于同包的类中，所以在创建接口时，最好用public修饰。

#### 接口和抽象类

###### 接口和抽象类都具有如下特征：
**1.** 接口和抽象类不能实例化，它们都位于继承树的顶端，用于被其它的类继承和实现。

**2.** 接口和抽象类都包含抽象方法，实现或继承抽象类的子类必须要实现这些抽象方法。

**3.** 接口和抽象类都能嵌套类。

###### 接口和抽象类不同特征:
**1.** 接口只能含有抽象方法，抽象类不仅可以含抽象方法，还可以含普通方法。

**2.** 一个类自能单继承，即只能一个抽象类，但一个类可以实现多个接口。

**3.** 抽象类可以包含构造器，构造器并不是用于创建对象，而是让子类调用该构造器完成抽象类里要完成数据的初始化，接口就没有构造器。

**4.** 接口不能定义静态方法，抽象类可以定义静态方法。

**5.** 接口里不能包含初始化块；但抽象类可以包含初始化块。

#### 面向接口编程

接口体现的是一种规范与实现分离的设计模式，充分利用好接口可以极好的降低程序的各种模块之间的耦合，从而提高系统的可扩展性与维护性。下面介绍一个面向接口编程的例子:

我假设一个场景,程序中有一个Computer类需要组合一个输出设备，现在有两种选择，第一种直接组合Printer(打印设备)对象，第二种是组合Output(打印接口)接口，第一种对象能实现Computer打印功能，但以后Computer类打印能要升级是不是要拆开电脑，即打开源码修改打印功能，若是修改一个Computer类还是可以，但是系统中有100个，或者1000个组合了Printer类，那就要修改100,1000个，那就麻烦了，那代码维护性极差。若Computer类组合Output接口，那打印设备，既打印类于打印接口完全分离，打印接口就不必知道打印设备具体怎么实现打印的，只需要打印设备遵守打印接口规则，生产自己所需的打印设备就ok了。这些代码的维护性与扩展性就很好了。例:

public interface Output {

	void print();
	
}


public class Computer {

	private Output output;
	
	public Computer(Output output){
		
		this.output = output;
		
	}
	
	public void print(){
		
		output.print();
		
	}
}

//Printer打印设备
public class Printer implements Output {

	public void print() {
		
		System.out.println("printer");
	}

}

//升级后的打印设备
public class BetterPrinter implements Output {

	public void print() {
		
		System.out.println("betterPrinter");

	}
}

public class OutputFactory {

	public Output getOutput(){
		
		//return new Printer();   //原来Printer打印设备，
		return new BetterPrinter();  //conputer打印设备升级
	}
	public static void main(String[] args) {
		
		OutputFactory ot = new OutputFactory();
		Computer computer = new Computer(ot.getOutput());
		computer.print();
		
	}
}

所以以后Computer类的打印设备升级,只需在getOutput()方法生产对应的打印设备，不必打开Computer源码修改组合的打印对象。





## 多态

#### 多态的定义和作用
##### 多态的定义
Java 引用变量有两种类型：一个是编译时类型，一个是运行时类型。编译时类型由声明变量时所使用的类型决定。运行时类型由实际赋给该变量的对象决定。如果编译时类型与运行时类型不一致时可能会出现多态。
简单的说将子类的对象赋值在父类引用上，再通过父类的引用调用子类重写的方法，就可以实现多态。或则将实现接口的对象赋值在接口对象上，然后再通过被赋值后的接口调用接口的方法，实现多态。

将超类的对象动态绑定到基类的引用上，然后再用该引用调用超类覆盖的方法，实多态调用

##### 多态的作用
多态不但能够改善代码的组织结构和可读性，还能创建可扩展的程序，无论在项目最初还是添加新功能的时候都是可“生长”的程序。
#### 多态的实现方式

现在假设有一个场景，我们需要开发个一几何画板,按一下画板上的绘画按钮，就可以画出不同的几何图形，按照正常做法我们会创建多个方法，每一个方法都绘制不同的几何图形，在分别调用绘画几何图形方法，如下次再需要添加某个图形，就需要打开画板源码，进行修改。这样对代码的维护性与扩展性极差。但是我可以将这些几何形的相同点抽出类，将绘画方法与实现分离。具体实现如下例子：

public abstract class Shape {
	
	abstract void onDraw();

}

public class Circle extends Shape {

	public void onDraw() {
		
		System.out.println("绘制圆形");
		
	}
}

public class Rectanle extends Shape {

	public void onDraw() {
	
		System.out.println("绘制正方形");
		
	}
}

public class Triangle extends Shape {

	void onDraw() {
		
		System.out.println("绘制三角形");
		
	}
}

public class Main {
	
	public static void main(String[] args) {
		
		ArrayList<Shape> array = new ArrayList<Shape>();
		array.add(new Circle());
		array.add(new Rectanle());
		array.add(new Triangle());
		for(int i = 0; i < array.size();i++){
			array.get(i).onDraw();
		}
	}
}

运行结果：

绘制圆形

绘制正方形

绘制三角形

**分析**：
可以看出我们将几何图形相同的部分抽出来，定义了一个抽象类Shape,在抽象类中定义了未实现绘画功能的绘画方法onDraw()，具体实现绘画功能由继承这个几何抽象类的类来实现。然后就可以将超类的对象动态的邦定到抽象类的引用上，调用onDraw()的方法，实现多态。若以后想再添加一个绘画五边形共功能时，只需继承Shape抽象类，并实现Ondraw()绘画功能，就使代码可以得到很好的扩展与维护。

#### 向上转型

什么是向上转型，由导出类转型成基类，在继承图上移动的，因此称为向上转型。即将导出类的对象动态的绑定在基类的引用上。例如：

public class Instrument {

	public void play(){
		System.out.println("Instrument=>play()");
	}
	
	public static void tune(Instrument i){
		i.play();
	}
}

ublic class Wind extends Instrument {

	public static void main(String[] args){
		
		Wind flute = new Wind();
		Instrument.tune(flute);  //向上转型
		
	}
}

在这个例子中，我们调用静态的方法tune()时，是将超类的Wind的对象传递给Instrument的引用i,但是编译器并没有报类型转换错误，而是导出类Wind对象flute与基类Instrument引用起作用了，我们将Wind引用转换为Instrument的引用的动作，成为向上转换。当然向上转换总是安全，但是会丢失超类中的数据或者方法，因为在超类继承基类时，总是在超类中添加新方法或者数据，而基类的引用就不能向超类中新添加的方法或者成员变量发送消息，所以造成向上转型容易丢失数据。

下面是向上转型的的图形表示：

```
graph BT
Wind--> Instrument
```


## 集合

#### 数组
##### 数组的特点
**1.** Java中要求所有的数组元素都是相同的数据类型，即一个数组只能存储一种数据类型的数据，而不能存储多种类型的数据。 

**2.** 数组一但初始化了，数组所占的空间被固定下来，数组的长度大小将不会改变。即数组的大小是固定。

**3.** 数组也是一种类型，它本身是一种引用。例如，int是一种基本类型，int[]（定义数组一种方式）就是一种引用。

**4.** 数组存储效率最高，访问速度极快。

##### 数组的定义
###### Java语言中定义数组的格式有两种：
**1.** type[] arrayName; 例如：int[] a;

**2.** type arrayName[]; 例如：int a[];

建议使用第一种数组定义格式，毕竟它表明类型是int[](一个int型数组)。

##### 数组的初始化

初始化数组有两种方式。

**静态初始化**:初始化时显式指定每个数组的元素的初始值，最后由系统确定数组长度。

其初始化格式如下：

arrayName = new type[]{element1,element2,element3,element4...};

例如：

a = new int[]{1,2,3,4};

数组a的长度为4。

**动态初始化**：初始化时指定数组长度，但数组元素值由系统设置默认值。

其初始化格式如下:

arrayName = new type[length];

例如：

a = new int[5];

数组a每个元素默认值为0。

##### 数组的访问
访问数组元素是通过在数组引用后紧跟一个方括号[]，方括号里填入访问数组的下标值。例如，

a[1]是访问a下标为1的值，即数组第二个值，其值为2。

##### 内存中的数组

数组是一种引用数据类型，数组引用变量只是一个引用，因此这个引用变量可以指向任何有效的内存。需要注意的是数组元素和数组变量在内存中是分开的，数组引用变量通常放在栈内存，数组元素放在堆内。如下图所示：

![image](http://images2015.cnblogs.com/blog/746338/201703/746338-20170302153151501-1224070627.png)


所以一个数组其实有两部分组成，一部分是由数组变量引用,即int[],存放在栈内存中，还有一部分是数组对象，即保存数组元素那部分，也就存放在堆内存中。

所以若要访问上图堆内存的元素，只能通过p[index]形式访问，也就是说数组引用变量是访问数组元素的根本方式。

###### 只要类型兼容，可以让一个数组变量指向另一个实际的数组，这种操作会让人产生数组的长度可变的错觉。例如：

public class Main {

	public static void main(String[] args) {
	
		int[] a= {5,7,20};
		int[] b = new int[4];
		System.out.println("b数组长度:" + b.length);
		System.out.println("a 数组元素:" + Arrays.toString(a));
		System.out.println("b 数组元素:" + Arrays.toString(b));
		b=a;  //把b的引用指向a的引用指向的数组。
		System.out.println("赋值后b数组长度:" + b.length);
	}
}

运行结果：

b数组长度:4

a 数组元素:[5, 7, 20]

b 数组元素:[0, 0, 0, 0]

赋值后b数组长度:3

由运行结果我们可以看出b数组长度似乎被改变了，但这只是一种错觉，下面我们分析下；

Main函数分别定义了两个数组，分别是数组a和数组b,它们在内存中存放由下图表示：

![image](http://images2015.cnblogs.com/blog/746338/201703/746338-20170302153409985-1487440707.png)


当代代码执行到"b=a;"时，它们在内存中存放由下图表示：

![image](http://images2015.cnblogs.com/blog/746338/201703/746338-20170302153422751-172661122.png)

所以数组b的长度大小并没有改变，只是b数组变量引用重新指向a数组引用变量指向的数组对象上，所以其输出数组长度是数组a的长度。只是b数组对象没有任何引用指向它，就等待垃圾回收器回收b数组对象占有的内存资源。

##### 多维数组

###### 二维数组的定义

二维数组其实质还是一维数组，只是其数组元素也是引用。数组元素保存的引用是指向一维数组。

二维数组定义的语法格式如下：

type[][] arrName;

例：

int a[][];


###### 二维数组的初始化

接着把这个二维数组执行初始化，同样当着一维数组类初始化。把这个二维数组当成一个一维数组，其元素的类型是type[]类型，则采用如下语法格式：

arrName = new type[length][];

这个一维数组的长度为length，其系统为每个元素值都是null。

例：

a=new int[4][];

假设数组变量a在main函数中定义的，则其在内存中如下图所示：

![image](http://images2015.cnblogs.com/blog/746338/201703/746338-20170302153515391-678937259.png)



初始化数组时可以指定最左边维的大小，也可以一次性指定每一维大小，例：

int[][] b =new int[3][4];


##### 数组的比较

Arrays类提供了重载后的equals()方法，用来比较整个数组。此方法适用于所有基本类型与Object都作了重载。数组相等的必要条件是元素个数相等，并且对应位置的元素也相等。

例：

public class Main {

	public static void main(String[] args) {
	
		int[] a1=new int[10];
		int[] a2=new int[10];
		Arrays.fill(a1, 47);
		Arrays.fill(a2, 47);
		System.out.println(Arrays.equals(a1, a2));
		
		a2[3] = 6;
		System.out.println(Arrays.equals(a1, a2));
		
		String[] s1 = new String[4];
		Arrays.fill(s1, "Hi");
		String[] s2 = {new String("Hi"),new String("Hi"),new String("Hi"),new String("Hi")};
		System.out.println(Arrays.equals(s1, s2));
	}
}

运行结果：

true

false

true

##### 数组元素的比较
###### 1.数组元素是基本类型与String类型的比较
这些类型的数组元素可以直接调用Arrays类的静态方法进行元素的比较，例如：

public class Test {

	public static void main(String[] args) {
	
		int[] a={24,45,2,63,23,6,4,254,564,3};
		System.out.println("数组a排序前");
		System.out.println(Arrays.toString(a));
		Arrays.sort(a);
		System.out.println("数组a排后(升序)");
		System.out.println(Arrays.toString(a));
		
		String[] s = {"A","D","C","a","B","F","d","E","Y","x","X","Z"};
		System.out.println("数组s排后前");
		System.out.println(Arrays.toString(s));
		
		Arrays.sort(s);
		System.out.println("数组s排后(升序)");
		System.out.println(Arrays.toString(s));
	}
}

运行结果：

数组a排序前

[24, 45, 2, 63, 23, 6, 4, 254, 564, 3]

数组a排后(升序)

[2, 3, 4, 6, 23, 24, 45, 63, 254, 564]

数组s排后前

[A, D, C, a, B, F, d, E, Y, x, X, Z]

数组s排后(升序)

[A, B, C, D, E, F, X, Y, Z, a, d, x]

###### 2.数组元素是一个复杂的对象

这种复杂的对象元素有两种比较方法，第一种是实现java.util.Comparator<T>接口。

**例**：

public class Student {

	public String name;
	public int age;
	
	public Student(String name, int age) {
		
		this.name = name;
		this.age = age;
	}

	public String toString() {
		
		return "[name=" + name+ ",age=" +age+ "]";
	}
}


public class Main {

	public static void main(String[] args) {
		Student[] students = {new Student("张三", 18),new Student("李四", 23),new Student("王五", 6),new Student("王二", 12)};
		System.out.println("students数组排序前:");
		System.out.println(Arrays.toString(students));
		Arrays.sort(students,new Comparator<Student>() {  //创建实现接口的匿名类

			@Override
			public int compare(Student o1, Student o2) {  //实现compare方法
				
				return o1.age - o2.age;       //按照升序比较
			}
		});

		System.out.println("students数组排序后:");
		System.out.println(Arrays.toString(students));
	}
}

运行结果：

students数组排序前:

[[name=张三,age=18], [name=李四,age=23], [name=王五,age=6], [name=王二,age=12]]

students数组排序后:

[[name=李四,age=23], [name=张三,age=18], [name=王二,age=12], [name=王五,age=6]]


第二种是创建一个实现java.lang.Comparable<T>接口的类,这个类自己就可以按一定规则比较大小的功能。

**例**：

public class Student implements Comparable<Student>{

	public String name;
	public int age;
	
	public Student(String name, int age) {
		
		this.name = name;
		this.age = age;
	}

	public String toString() {
		
		return "[name=" + name+ ",age=" +age+ "]";
	}

	@Override
	public int compareTo(Student o) {
		
		
		return age - o.age;
	}
}

public class Main {

	public static void main(String[] args) {
		Student[] students = {new Student("张三", 18),new Student("李四", 23),new Student("王五", 6),new Student("王二", 12)};
		System.out.println("students数组排序前:");
		System.out.println(Arrays.toString(students));
		Arrays.sort(students);
		System.out.println("students数组排序后:");
		System.out.println(Arrays.toString(students));
	}
}

运行结果：

students数组排序前:

[[name=张三,age=18], [name=李四,age=23], [name=王五,age=6], [name=王二,age=12]]

students数组排序后:

[[name=李四,age=23], [name=张三,age=18], [name=王二,age=12], [name=王五,age=6]]

以上就是简单介绍Java
#### List

List一个接口集合，它是由Collection接口继承来的子接口。它保存数据是按添加顺序保存的。List集合代表一个元素有序、可重复的集合，集合中的每个元素都有其对应的顺序索引。List集合允许元素重复插入，List默认插入的索引从0开始，然后插入索引的位置依次递增。List集合可以按索引访问List集合指定的位置。

有两种类型的List,分别是ArrayList与LinkedList，下面分别讲述它们：

##### ArrayList

基本的ArrayList，它擅长随即机问元素，但是在List集合中间插入与移除元素时较慢，LinkedList还添加了可以使其用作栈，队列或双端队列的方法。

ArrayList是线程不安全的，当多个线程访问同一个ArrayList集合时，必须手动保持该集合线程同步，或者利用Collections工具保证该集合线程安全，代价是程序性能较低。

以数组保存数据。

以数组保存的集合随即访问性能较好。

##### LinkedList

LinkedList在List集合中间进行插入和删除付出的代价较低，但随机访问方面相对比较慢。

LinkedList实现了线程同步的，但各方面的性能都有所下降。

以链表保存数据。

以链表为底层的实现集合在执行插入、删除操作时有很好的性能。

**注意：** 迭代时，以链表为底层的集合比以数组为底层的集合性能比较好。



##### List集合删除指定元素的原理

List集合删除指定元素时，首先指定元素与List集合元素依次调用equals方法作比较，当两个对象相等时，equals返回ture，然后就删除指定元素在List集合相等的元素，例：

public class A {

	public boolean equals(Object obj) {
	
		return true;
	}
}

public class Main {

	public static void main(String[] args) {

		List<Integer> list = new ArrayList<Integer>();
		list.add(1);
		list.add(2);
		list.add(3);
		list.add(4);
		System.out.println("before remove");
		System.out.println(list.toString());
		System.out.println("after remove");
		list.remove(new A());
		System.out.println(list.toString());
		list.remove(new A());
		System.out.println(list.toString());
	}
}

运进结果：

before remove

[1, 2, 3, 4]

after remove

[2, 3, 4]

[3，4]

分析：首先我们创建一个类A,并且在类A中重写equals方法。我们将equals方法总是返回真，最后List总是删除第一个元素。


#### Set

Set是Collection接口继承来的子接口，Set不保存重复的元素。

Set 判断两个对象相同不是使用==运算符，而根据equals方法。也就是说只要对象用equals方法比较返回true,Set就不会接受这个对象，反之，Set就会接受这个对象，即使相同的对象。

#####  HashSet类

HashSet是Set接口的典型实现，大多数时候使用Set集合时就是使用这个实现类。HashSet按Hash算法来存储集合中的元素，因此具有很好的存取和查找性能。

###### HashSet具有以下特点：

**1.** 不能保证元素的排列顺序，顺序有可能发生改变。

**2.** HashSet不是同步的。

**3.** 集合元素可以null。

==HashSet集合决定存储位置的是由hashCode()方法决定的。当两个对象通过equals方法比较返回true,但它们的hashCode()方法返回值不相同时，也会将数据添加成功，即重写元素的equals方法与hashCode()方法。==

**例1**：

public class A {

	public int count;
	public A(int count){
		
		this.count = count;
		
	}
	
	public boolean equals(Object obj) {
	
		return false;  //总是false
	}
	
	public int hashCode() {
		
		return count;
		
	};
	
	public String toString() {
		
		return this.getClass().toString()+count;
	}
}

public class Main {

	public static void main(String[] args) {
		
		HashSet<A> hs =new HashSet<A>();
		hs.add(new A(1));
		hs.add(new A(1));
		hs.add(new A(1));
		hs.add(new A(1));
		System.out.println(hs);
	}
}

运行结果：

[class HashSet.A1, class HashSet.A1, class HashSet.A1, class HashSet.A1]

例2：

public class A {

	public static int id = 0;
	public final int count = id++;
	
	public boolean equals(Object obj) {
	
		return true;  //总是false
	}
	
	public int hashCode() {
		
		return count;
		
	};
	
	public String toString() {
		
		return this.getClass().toString()+count;
	}
}

public class Main {

	public static void main(String[] args) {
		
		HashSet<A> hs =new HashSet<A>();

		hs.add(new A());
		hs.add(new A());
		hs.add(new A());
		hs.add(new A());
		System.out.println(hs);
	}
}

运行结果：

[class HashSet.A0, class HashSet.A1, class HashSet.A2, class HashSet.A3]

由上两题可知将两个相同数据添加到hashset集合成功。原因如下:

对于集合类HashSet、HashMap等和hash有关的类（以HashSet为例），是通过hash算法来散列对象的。对HashSet而言，存入对象的流程为：根据对象的hash码，经过hash算法，找到对象应该存放的位置，如果该位置为空，则将对象存入该位置；如果该位置不为空，则使用equals()比较该位置的对象和将要入的对象，如果两个相等，则不再插入，如果不相等，根据hash冲突解决算法将对象插入其他位置。


##### LinkedHashSet类

LinkedHashSet是Hashset的子类，它也是根据hashCode（）方法来决定数据的存储位置，它内部有链表来维护数据的插入顺序，所以其性能比Hashset差，但其迭代访问set里全部元素时，其速度快。

由于LinkedHashSet是继承HashSet的，所以其也不能添加重复的元素。

##### TreeSet类

TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态。

###### 自然排序

TreeSet会调用集合元素的compareTo(Object          obj)方法来比较元之间的大小关系，然后将集合按升序排序，这种方式叫自然排序。 

TreeSet 通过判断两个对象是否相等的唯一标准是通过CompareTo(Object obj)方法。

**注意**:将一个对象添加到TreeSet时，必须将对象的类实现Comparable接口，否则程序将抛出异常。

**例**：

public class Err {

}

public class Main {

	public static void main(String[] agrs){
		
		TreeSet ts = new TreeSet();
		ts.add(new Err());
		ts.add(new Err());
	}
}

运行结果：

Exception in thread "main" java.lang.ClassCastException: TreeSet.Err cannot be cast to java.lang.Comparable

##### 定制排序
TreeSet 自然排序是按升序排序的，但我们可以定义TreeSet变量时，可以通过向TreetSet的构造器传入实现Comparator接口的对象，通过重写compare()方法，进行定制排序。例：

public class Student {

	public int age;

	public Student(int age) {
		this.age = age;
	}

	public String toString() {
		return "Student [age=" + age + "]";
	}
}


public class Main {

	public static void main(String[] agrs){
		
		TreeSet<Student> ts = new TreeSet<Student>(new Comparator<Student>() {
			
			public int compare(Student o1, Student o2) {
				return o2.age - o1.age;  //按升序排序
			}
		});
		
		ts.add(new Student(4));
		ts.add(new Student(13));
		ts.add(new Student(43));
		ts.add(new Student(24));
		System.out.println(ts);
	}
}

运行结果：

[Student [age=43], Student [age=24], Student [age=13], Student [age=4]]

上面的程序通过传入实现compare()方法的匿名类对象，该对象负责对ts集合排序，所以当我们向集合添加元素时，对Student类无须实现Comparable接口，因此Student的对象无须本身比较大小，而由实现Comparator接口类的对象负责比较大小进行排序。

TreeSet判断两个对象相等的标准是通过Comparator比较两个元素返回0，这样TreeSet重复添加元素。

##### Set实现类的性能分析

需要添加、查询元素操作时，HashSet性能比较好。

需要将元素保持排序时，使用TreeSet。

#### Map

Map是一个接口集合，Map用于保存映射有关的数据，即以键值对的形式保存。因此Map集合保存着两组数据，一组key,一组是value,map里的key不能重复。

实现Map接口下HashMap,LinkedHashMap,SortedMap(接口)，TreeMap，WeakHashMap，ConcurrrentHashMap




##### HashMap

Map基于散列表的实现，插入和查询开销是固定的，可以通过构造器设置容量与负载因子，以调整容器容量。

HashMap是线程不安全的实现，因此其性能比Hashtable高一点。

HashMap可以将null作为key和value。

由于hashMap可以存放null,但只能有一个键key存放null，却可以有多个value存放null。

HashMap 按一定规则保存数据。

#####  Hashtable

Hashtable 是线程安全的类，若是有多个线程访问Map对象时，使用Hashtable实现类会更好。

HashTable 不允许使用null作为key和value,若试图将null放进Hashtable中，会引异常。

##### LinkedHashMap 

取得键值对顺序是插入顺序，或是最近最少使用的顺序，只是速度比HashMap慢一点，但是使用迭代访问数据时，速度反而快一些，这是LinikedHashMap内部维护数据是以链表形式的。

LinkedHashMap按插入顺序保存数据。

linkedHashMap需要维护元素的插入顺序，所以其性能比HashMap要低。


##### TreeMap

基于红黑树的实现，每一个key-value对即作为红黑树的一个节点。TreeMap存储key-value（节点）时，需要根据key对节点排序。

TreeMap默认按照比较结果升序保存数据，TreeMap的特点是所看的结果都是经过排序的，是因为其实现Comparator与Comparable接口。

TreeMap有两种排序的方法:

自然排序：TreeMap的所有的key必须实现Comparable接口，而且所有的key都是同一个类的对象，否则会抛出异常。

定制排序：创建TreeMap时，传入一个Comparator对象，该对象负责对TreeMap中的所有key进行排序。采用定制排序时不要求Map的key实现Comparable接口。

**注意**：使用自定义类作为TreeMap的key,应该重写该类的equals()方法和comparaTo方法时应保持一致的返回结果：两个key通过equals()方法比较返回为true时，compareTo()方法比较应该返回0。如果equals方法与compareTo()方法的返回结果不一致时，TreeMap与Map接口的规则就会冲突。

下面列是一个关于treeMap自定义排序的例子，例：

public class Key implements Comparable<Key>{
	
	int key;
	public Key(int key){
		this.key = key;
	}
	
	public String toString() {
		
		return "Key[key : "+key+"]";
	}
	
	//根据key来判断两个对象是否相等
	public boolean equals(Object obj) {
		
		if(this == obj){
			return true;
		}
		if(obj != null && Key.class == obj.getClass()){
			
			Key k = (Key) obj;
			return k.key == this.key;
		}
		return false;
	}
	
	//根据key属于来判断两个对象的大小
	public int compareTo(Key o) {
	
		return  o.key - this.key;  //按降序排列
	}
}

public class Main {

	public static void main(String[] args) {
		
		TreeMap<Key, String> tm = new TreeMap<Key, String>();
		tm.put(new Key(3), "Java");
		tm.put(new Key(-4), "JavaSript");
		tm.put(new Key(6), "C++");
		tm.put(new Key(2), "C#");
		System.out.println(tm);
	}
}

运行结果：

{Key[key : 6]=C++, Key[key : 3]=Java, Key[key : 2]=C#, Key[key : -4]=JavaSript}

##### WeakHaspMap

一种弱键映射，若映射之外没有引用指向某个键，键就会自动被垃圾收集器收回。

HashMap的key保留了对实际对象的强引用，只要HashMap对象没有销毁，HashMap所有的key所引用的对象就不会被垃圾回收，HashMap也不会自动删除key所对应的key-value对；但WeakHashMap的key只保留对实际对象的弱引用,如这些key没有被其的强引用所使用，那么key所引用的对象可能会被垃圾回收。WeakHashMap也可能自动删除这些key所对应的key-value对。如下程序：

public class Main {

	public static void main(String[] args) {
		
		WeakHashMap whm = new WeakHashMap();
		//三个key都是匿名字符串对象（没有其他引用）
		whm.put(new String("语文"), "良好");
		whm.put(new String("数学"), "优秀");
		whm.put(new String("英语"), "中等");
		
		//该key是一个系统缓存的字符串对象
		whm.put("java", "精通");
		System.out.println(whm);
		
		//通知系统立即进行垃圾回收
		System.gc();
		System.runFinalization();
		System.out.println(whm);	
	}
}

运行结果：

{java=精通, 数学=优秀, 英语=中等, 语文=良好}

{java=精通}

**分析**：三个key都是匿名的字符串对象,WeakHashMap只保留了对他们的弱引用，这样垃圾回收器会自动删除这三个key-value对。而whm.put("java", "精通")的key是一个字符串直接量，保留了该字符串的强引用，所以垃圾回收器不会回收它。

**注意：** 如果让WeakHashMap的Key来保留对象的弱引用，则不要让该key所引用的对象具有任何强引用，否则会失去使用WeakHashMap的意义。



##### concurrentHashMap 

一种线程安全的Map,它不涉及同步加锁。

## 泛型

#### 泛型的定义和作用

##### 泛型的定义
泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。 

##### 泛型的作用

泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率。

#### 泛型的使用

提到泛型的使用，我们应该想到的是集合，泛型在集合中广泛的使用，比如Collection<E>就是泛型集合接口，下面我们来举个List<E>泛型类才的使用方法。

例：

public class Main {

	public static void main(String[] args) {
	
		List<String> ls = new ArrayList<String>();
		ls.add("Java");
		ls.add("C++");
		ls.add("C");
		System.out.println(ls);

	}
}

运行结果：

[Java, C++, C]

分析：上面的泛型List<E>类是含有泛型类型的集合，我们对象这个泛型类型传入了一个String类型，所以List集合可以添加字符串数据，非字符串数据编译会出错。

#### 自定义泛型的接口、泛型类和泛型方法。

##### 自定义泛型接口

定义接口时指名一个类型形参，该参数名为大写的字母，其基本语法式：

[修饰符] interface 接口名<E> {

    //接口体...
}

###### 实现接口的语法格式参数说明

**修饰符**：可选，一般Public

**接口名<E>**： 必选，参数类型为字母大写，比如字母 E

例如：

public interface Shape<T> {
	
	public void print();
}


##### 泛型类

定义一个类时指名一个类型参数，该参数为字母大写，就可以定义一个泛型类，其基本语法格式如下：

[修饰符] class 类名<T> {
    
    //类体...
}

例如：

public class Apple<T> {

	T data;
	
	public Apple(T data){
		this.data = data;
	}
	
	public T getData() {
		return data;
	}

	public void setData(T data) {
		this.data = data;
	}

	public static void main(String[] args) {
		
		Apple<String> as = new Apple<String>("Android");
		System.out.println(as.getData());
		
		Apple<Integer> ai = new Apple<Integer>(10);
		System.out.println(ai.getData());
	}
}

运行结果：

Android

10

分析：通过对类添加类型参数T，我们可以对Apple对对象写入或者读取任何类型的对象，这就可以使改类的代码可以重复使用，该类型参数T可以在类的成员变量和方法中当作普通类型使用。但是在该类的定义申明中必须传入类型实参。

##### 泛型方法

前面我们在定义类、接口时使用了类型参数，在该类的方法定义和Filed定义、接口的方法定义中，这样类型都可以当做普通类型来使用。若我们在定义类、接口时没有使用到类型参数，但是在定义方法时也可以定义类型参数，其本语法格式如下：

修饰符<T,S> 返回值类型 方法名（参数列表）{

    //方法体...
}

例如：

public class Main2 {

	static <T> void CopyAction(T[] a,Collection<T> c){
		for (T t : a) {
			c.add(t);
		}
	}
	
	public static void main(String[] args) {
		
		Object[] oa = new Object[10];
		Collection<Object> co = new ArrayList<Object>();
		//下面的代码中T代码Object类型
		CopyAction(oa, co);
		
		String[] os = new String[10];
		Collection<String> cs = new ArrayList<String>();
		//下面的代码中T代码String类型
		CopyAction(os, cs);
		
		Integer[] oi = new Integer[10];
		Collection<Integer> ci = new ArrayList<Integer>();
		//下面的代码中T代码Integer类型
		CopyAction(oi, ci);
	}
}

分析：上面的程序定义了一个泛型方法，该方法中定义了一个类型形参，这个T类型形参就可以在该方法内当作普通类型使用。该类型只能在该方法中使用。与类、接口中使用泛型不同的是，方法中的泛型参数无须显示传入实际参数，而是编译器根据实参类型的值，推断出直接的类型参数。

#### 类型通配符

为了表示各种泛型的父类，可以使用类型通配符，类型通配符是一个问号(?)。我们可以将一个类型通配符作为类型实参传递给类型参数。这个问号被称为通配符，这个元素类型可以匹配任何类型。下面我们举三个例。

**例1：**

public class Main {
	public static void addList(List l){
		System.out.println(l.toString());
	}
	public static void main(String[] args) {
	
		List<String> list = new ArrayList<String>();
		list.add("A");
		list.add("B");
		list.add("C");
		addList(list);
	}
}

运行结果：

[A, B, C]

分析：由于List是集合接口，可以将任何实现该接口的集合对象传给它，但是这个List接口是个泛型接口，没有传入参数类型，编译器会给出一个警告，但并不影响结果。下面我们来解决这个警告，我们将List接口传入Object类型，看下面例子。

**例2：**

public class Main {
	public static void addList(List<Object> l){
		System.out.println(l.toString());
	}
	public static void main(String[] args) {
	
		List<String> list = new ArrayList<String>();
		list.add("A");
		list.add("B");
		list.add("C");
		addList(list);  //这里编译出错，
	}
}

分析：当编译器编译到addList(list);这句时出现编译时错误。错误是不能将List<Object>类型应用于List<String>类型上。虽然String 是 Object 是导出类，但在泛型里，List<String> 并不是List<Object>的导出类。为了解决泛型集合赋值出错问题，我们引入泛型通配符,下面看下例子。

注意：若 A是B的子类型（子类或子接口），G是具有泛型声明的类或接口，但G<A>不是G<B>的子类型，即它们是没有继承关系的类型。

**例子3：**

public class Main {
	
	public static void addList(List<?> l){
		System.out.println(l.toString());
	}
	
	public static void main(String[] args) {
	
		List<String> ls = new ArrayList<String>();
		ls.add("A");
		ls.add("B");
		ls.add("C");
		addList(ls);
		
		List<Integer> li = new ArrayList<Integer>();
		li.add(1);
		li.add(2);
		li.add(3);
		addList(li);
	}
}

分析：上例中List<?>是一个未知类型元素的List,它的元素类型可以匹配任何类型，即List<String>和List<Integer>类型等。但是在静态方法里,不能对list添加任何数据，但可以添加null。这是因为一个集合类型参数是一个通配符时，我们不能向这个集合写入任何对象，因为编译器对这个集合的类型是无法预知的，所以会出现编译时错误。但是我们可以对这个集合读取集合的对象。因为读取时返回类型编译器是明确的，即返回Object类型。

##### 设定类型通配符的上限

有时候我们希望通配符并不匹配任何类型，我们只希望它能匹配一定范围的类型，比如匹配继承某父类型的类型参数。我们可以设定通配符上限,用关键字**extends**。

**语法基本格式**： G<? extends T>

G是具有泛型声明的类或接口

T是父类型

下面我们通过两个例子展开讲设定类型通配符的好处，例子一用类型通配符解决问题。

例子1：

public abstract class Shape {

	public abstract void draw(Canvas c);
	
}

public class Circle extends Shape {

	private  static int i =0;
	private final int id = i++;
	
	public void draw(Canvas c) {
	
		System.out.println("draw Cicle"+id);
	}

}

public class Rectangle extends Shape {

	private  static int i =0;
	private final int id = i++;
	public void draw(Canvas c) {
		
		System.out.println("draw retangle"+id);
	}
}

public class Main {

	public static void draw(List<?> shapes){
		
		for (Object object : shapes) {
			
			Shape shape = (Shape) object;
			shape.draw(null);
		}
	}
	public static void main(String[] args) {
		
		List<Circle> lc = new ArrayList<Circle>();
		lc.add(new Circle());
		lc.add(new Circle());
		lc.add(new Circle());
		draw(lc);
		List<Rectangle> lr = new ArrayList<Rectangle>();
		lr.add(new Rectangle());
		lr.add(new Rectangle());
		lr.add(new Rectangle());
		draw(lr);
		
	}
}

运行结果：

draw Cicle0

draw Cicle1

draw Cicle2

draw retangle0

draw retangle1

draw retangle2

分析：在Main类中的静态方法draw的类型参数中使用了List<?>类型，它可以匹配任何类型，问题是shangmian的draw方法体中，使用了泛型还需要强制类型转换，这是我们不想看到的。但是我们可以通过设定泛型通配符类型上限，这样这个通配符类型就可以表示所有的List<shape>类型的父类型,如下例子.

例2的代码只需修改Main类中draw方法，其它代码不变，draw方法修改后的代码如下：

public static void draw(List<? extends Shape> **shapes**){
		
		//使用被限制的泛型通配符
		for (Shape shape : shapes) {
			shape.draw(null);
		}
	}
	
分析：

List<? extends Shape>是受限制例子，此处问号(?)代表一个未知类型，就像前面的通配符一样，但此处的未知类型一定是Shape的子类，也包括Shape对象本身。因此Shape就是这通配符的上限。所以在上面修改后的draw方法中，编译器就能知道Shape是所有匹配符的超类，我们就可以在方法体中使用Shape类。
	
注意：由于编译器无法明确受限制的通配符具体类型，我们不能将Shap的对象以及Shap的任何子对象加入到这个泛型集合中。即**shapes.add(0,new Rectangle);** 是错误的。


#####  超类型通配符

可以声明通配符是由某个特定类的任何基类来界定，方法是指定<? super MyClass>,甚至或者使用类型参数：<? super T>(尽管我们不能对泛型参数给出一个超类型边界；既不能声明<T super MyClass>),这就是超类型通配符。

###### 超类型通配符作用：

**1.** 可以安全的传入一个类型对象到泛型类型中。

**2.** 可以向泛型集合中写入数据

下面我们来验证超类型通配符的作用，为了省写时间，我们的Shape类，Circle类和Rectangle类依是上例题中保持不变，我们将Main类修改如下：

public class Main2 {

	public static void add(List<? super Shape> shapes){
		
		shapes.add(new Circle());
		shapes.add(new Rectangle());
		
	}

	public static void main(String[] args) {
		
		List<Shape> ls = new ArrayList<Shape>();
		add(ls);
		System.out.println(ls.size());
	
	}
}

运行结果：2

分析：参数Shape是Shape的某种基类型的List,这样你就可以向泛型List集合添加Shape或Shape的子类型的对象，并且种添加是安全的，编译器是能预知的。所以超类型解决了通配符泛型集合不能写入数据的问题。



#### 设定类型形参的上限

Java中不仅允许在使用通配符形参时设定上限，而且可以在定义类型形参时设定上限，用于表示传给该类型形参的实际类型要么是该上限类型，要么是该子类型，例如：

public class Apple<T extends Number> {
	
	T t;
	public static void main(String[] args) {
	
		Apple<Integer> ai = new Apple<Integer>();
		Apple<Double> ad = new Apple<Double>();
		Apple<String> as = new Apple<String>(); //编译出错

	}
}

分析：由于String 不是NUmber的子类，所以出错。


## 并发

#### 线程和进程的该念

程序：系统要完成的一个任务，就是一个程序。

进程：每个运行中的程序就是一个进程 。

线程：每个运行的程序（进程）内部可能会包含多个顺序执行流，每个执行流就可以看做线程。

线程是一个顺序执行流，它是进程的组成部分，一个进程可以有多个线程，
##### 线程与进程的各种特

###### 进程的特性
1.独立性：进程是系统中独立存在的实体，它可以拥有自己独立的资源，每个进程都拥有自己私有的地址空间，其他进程不能访问这个进程空间内的数据。

2.动态性：进程与程序的区别在于，程序是静态的，进程是动态的，程序只是一个静态的指令集合，而进程是一个正在系统中运行的指令集合，有生命周期等时间概念； 
3.并发性：进程之间，可以交替执行，提高程序执行效率。 


###### 线程的特性 
1.共享数据：进程之间不能共享内存，但线程可以共享同一片内存中的数据； 

2.效率高：系统创建进程需要为该进程重新分配系统资源，但创建线程的代价很小，因此用多线程实现多任务并发比多进程实现并发的效率高； 

#### Runnable 和Tread

在Java中可有两种方式实现多线程，一种是继承Thread类，一种是实现Runnable接口。下面分别列了两种实现多线程的方法。

继承thread类，例如：
public class MyThread extends Thread {

	private String name;
	public MyThread(String name){
		this.name = name;
	}
	
	public void run() {
		
		for(int i = 0; i < 10; i++){
			System.out.println(name + ":" + i);
		}
	}
}

public class Main {

	public static void main(String[] args) {
		
		MyThread mt1 = new MyThread("线程a");
		MyThread mt2 = new MyThread("线程b");
		mt1.start();
		mt2.start();
	}
}

注意：同一个mt1不能start()两次，否则会抛出异常。

实现接口Runnable类，例如：

public class MyThread implements Runnable {

	private String name;
	public MyThread(String name){
		this.name = name;
	}
	
	public void run() {
		
		for(int i = 0; i < 10; i++){
			System.out.println(name + ":" + i);
		}
	}
}

public class Main {

	public static void main(String[] args) {
		
		MyThread mt1 = new MyThread("线程a");
		MyThread mt2 = new MyThread("线程b");
		
		new Thread(mt1).start();
		new Thread(mt2).start();
	}
}

注意：同一个mt1能start()两次，不会抛出异常。

###### 对两种实现多线程总结：

在程序开发多线程时，应该选择Runnable接口实现多线程，这样可以使一个类避免单继承的弊端，因为一个类可以实现多个接口。选择Runnable接口还可以实现资源共享。

下面我们来证明下Runnable能实现资源共享

继承thread类，例如：

public class MyThread extends Thread {

	private int ticket = 10;
	
	public void run() {
		
		while(ticket > 0){
			System.out.print("卖票 T"+ ticket);
			ticket--;
		}
	}
}

public class Main {

	public static void main(String[] args) {
		
		MyThread mt1 = new MyThread(); //线程1
		MyThread mt2 = new MyThread(); //线程2
		MyThread mt3 = new MyThread(); //线程3
		
		mt1.start();
		mt2.start();
		mt3.start();
	}
}

运行结果：

卖票 T5 卖票 T4 卖票 T3 卖票 T2 卖票 T1 卖票 T5 卖票 T4 卖票 T3 卖票 T2 卖票 T1 卖票 T5 卖票 T4 卖票 T3 卖票 T2 卖票 T1 

分析：从输出结果可以看出三个线程每个线程分别卖了5张车票，总共买了15张，并没有实现线程间的资源共享。

注意：Thread implements Runnable,Thread其实是实现了Runnable接口得来的。
实现接口Runnable类，例如：

public class MyThread implements Runnable {

	private int ticket = 5;
	
	public void run() {
		
		while(ticket > 0){
			System.out.print("卖票 T"+ ticket + " ");
			ticket--;
		}
	}
}

public class Main {

	public static void main(String[] args) {
		
		MyThread mt = new MyThread();
		new Thread(mt).start();  //线程1
		new Thread(mt).start();  //线程2
		new Thread(mt).start();  //线程3
	}
}

运行结果：卖票 T5 卖票 T4 卖票 T3 卖票 T2 卖票 T1 

分析：总共卖了5张票，实现了线程间的资源共享，所以实现Runnable接口能实现线程间的资源共享。


###### 线程状态转换图如下

![image](http://images2015.cnblogs.com/blog/746338/201703/746338-20170306155900984-1988155795.png)

###### 线程死亡的3种方式结束，即处于死亡状态。

**1.** run()或call()方法执行完成，线程正常结束。

**2.** 线程抛出一个未捕获的Exception或Error

**3.** 直接调用stop方法类结束线程，但该方法容易导致死锁，不推荐使用。

**注意：** 当主线程死亡后，其它线程并不会受影响。

##### 后台线程

后台线程是运行在后台的，它的任务是为其它线程提供服务的。后台线程又称守护线程。JVM的垃圾回收线程是典型的后台线程。

后台线程典型的特点是：前台线程都死了，后台线程自动死亡。

设置后台线程的代码如下：

t.setaemon(true); //将将线程设置为后台线程。

若没有设置后台线程，默认的是前台线程，如main，但后台线程创建的线程默认的是后台线程。




#### Thread类中的start和run方法。

##### start方法

 start()方法是线程安全方法。Thread子类对象调用start()方法时，就代表重新启动一个线程，只不过该线程处于就绪等待中，当该线程一旦得时间片断时，就会从就绪状态转到运行状态，该线程中的run()方法就开始执行。当run()方法时，无须等待run()方执行完毕而直接继续执行调用start()方法后面的代码。这就真正实现多线程,当run()方法执行完毕，该子线程也就进入死亡状态。但要记住的是同一个Thread子类对象不能重复调用start方法，只能调用一次，否则会抛出异常，也不能对已经死亡的线程再次调用start()方法，否则抛出异常。
 
##### run方法
 
 run（）是线程不安的方法，其实该方法是重写了Runnable接口的run()方法得来的。它是一个线程体方法，包含了线程要执行的代码。但run（）方法只不过是Thread一个普通的方法，若直接调用该方法，并没有启动一个新线程，程序依旧在当前线程里执行，直到run()方法执行完毕，才可以继续执行后面的代码。并没有实现线程之间的同步。

#### volatitle 变量
 
当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。

而volatile关键字就是提示VM：对于这个成员变量不能保存它的私有拷贝，而应直接与共享成员变量交互。 
##### volatitle的作用

**可见性：** 可见性，是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。

**有序性：** 可见性，即程序执行的顺序按照代码的先后顺序执行。volatile关键字能确保变量在线程中的操作不会被重排序而是按照代码中规定的顺序进行访问。

**使用建议：** 在两个或者更多的线程访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，不必使用。

#### 创建线程安全的Singleton

public class Singleton {

	private static Singleton singleton = new Singleton();
	
	private Singleton(){
		
	}
	
	public static Singleton getSingleton(){
		return singleton;
	}
}


#### 

#### 原子性

原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。


#### 死锁和同步

##### 同步

当使用一个多线程访问同一个数据时，很容易出现线程安全问题。所以我们引入线程间的同步。

###### 代码块同步

使用同步监视器的通用方法就是同步代码块。同步代码块的语法格式如下：

synchronized(obj){
    
    ...
    //此处代码块就是同步代码块
}

obj就是同步监视器，上面代码块的含义是：线程开始执行同步代码块之前，必须先获得同步监视器的锁。

###### 同步方法

同步方法就是使用synchronized关键字来修饰某个方法，则方法就是同步方法。同步方法无须指定同步监视器，同步器就是this,即对象本身。

同步方法的基本语句如下：

修饰符 Synchronized 返回类型 方法名（参数列表）{

    ...
    //要同步的函数体
}

注意：synchronized关键字可以修饰方法，可以修饰代码块，但不能修饰构造器、属性等。

拥有同步方法的可变类是线程安全类，可变类的线程安全是降低程序的运行效率作为代价的，为了减少线程安全带来的负面影响，可以采取如下策略：

1. 不要对线程安全类所有方法同步，只对那些改变竞争资源的方法进行同步控制。
 
2. 可变类有两种运行环境：单线程和多线程。可以为可变类提供两个不同版本。

##### 同步锁(Lock)

Lock 提供供了比synchronized方法和synchronized代码块更广泛的锁定操作。Lock实现多线程同步更灵活的结构，它是控制多个线程对共享资源进行访问的工具。索提供了对共享资源的访问，每次只能有一个线程对Lock对象枷锁。线程开始访问共享资源前应先获得Lock对象。

Java中有两个根接口，分别是Lock和ReadWrite，分别有实现该接口的类，程序中用的最多的是实现接口Lock的类ReentrantLock，下面是ReentrantLock使用方法格式如下：

class X {
        
        //定义锁对象
        ReentrantLock lock = new ReentrantLock();
        // ...
        
        //定义需要保证线程安全的方法
        public void m() { 
          //  assert !lock.isHeldByCurrentThread();
          //加锁
            lock.lock();
            try {
            
                // 需要保证线程安全的代码
                // ... method body
            } finally {
            
                lock.unlock();
                
            }
        }
      }

注意：ReentrantLoc对象必须是多个线程中同持有的是同一把锁，否则不能实现并发同步。


##### 死锁

当两个线程相互等待对方释放同步监视器时就会发生死锁。

下面我们来举个死锁的例子，如下：

public class A {
	
	public synchronized void foo(B b){ 
		
		System.out.println("当前线程名:" + Thread.currentThread().getName() + ",进入 A=〉foo()方法里");
		
		try {
			Thread.sleep(200);
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		System.out.println("当前线程" + Thread.currentThread().getName() + "企图进入  B=〉last()方法中");
		
		b.last();
	}

	public synchronized void last() {
		
		System.out.println("当前线程名:" + Thread.currentThread().getName() + ",进入 A=〉last()方法里");
	}
}

public class B {

	public synchronized  void last() {
		
		System.out.println("当前线程名:" + Thread.currentThread().getName() + ",进入 B=〉last()方法里");
		
	}
	
	public synchronized void fun(A a){
		
		System.out.println("当前线程名:" + Thread.currentThread().getName() + ",进入 B=>fun()方法里");
		try {
			Thread.sleep(200);
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		System.out.println("当前线程" + Thread.currentThread().getName() + "企图进入  A=〉last()方法中");
		
		a.last();
	}
}

public class DeadLock implements Runnable {

	A a = new A();
	B b = new B();
	
	public void run() {
		
		Thread.currentThread().setName("子线程");
		b.fun(a);
		System.out.println("进入副线程之后");
	}

	public void init() {
	
		Thread.currentThread().setName("主线程");
		a.foo(b);
		System.out.println("进入主线程之后...");
	}

}

public class Main {

	public static void main(String[] args) {
		
		DeadLock dl = new DeadLock();
		new Thread(dl).start();
		dl.init();
	}
}


运行结果：

当前线程名:主线程,进入 A=〉foo()方法里

当前线程名:子线程,进入 B=>fun()方法里

当前线程子线程企图进入  A=〉last()方法中

当前线程主线程企图进入  B=〉last()方法中

分析：有程序运行结果可知，程序进入僵持状态。是因为程序中A对象和B对象的方法都是同步方法，也就是A对象和B对象都是同步锁。程序中有两个线程执行，主线程先执行init()方法，子线程再执行run()方法。下面是执行步骤：

1. 主线程：init()->持A锁->进入a.foo()里->sleep(200)->

2. 子线程：run()->持B锁->进入b.fun()里->sleep(200)->

3. 主线程：init()->持A锁->进入a.foo()里->sleep(200)->企图进入b.last()方法而诸塞->

4. 子线程：run()->持B锁->进入b.fun()里->sleep(200)->企图进入a.last()方法而诸塞->
 
5. 主线程：init()->持A锁->进入a.foo()里->sleep(200)->企图进入b.last()方法而诸塞->持有A锁等待拥有B锁

6. 子线程：run()->持B锁->进入b.fun()里->sleep(200)->企图进入a.last()方法而诸塞->持有B锁等待拥有A锁
 
所以最好结果是两个线程各自等待对方持有的锁而僵持，程序出现死锁状态。

### 线程通信

 - 线程间的通信，可以借助Object类提供的wait()、notify()和notifiyAll()3个方法，这3个方法不属于Thread类，而是属于Object类。
 
- 使用Condition控制线程通信


下面我们举个存钱取钱的例子：


    public class ShopThread implements Runnable {

	private PriorityQueue<Integer> pqi;
	private int MAX_SIZE;
	ReentrantLock lock = new ReentrantLock(true);
	Condition consumer = lock.newCondition();
	Condition producer = lock.newCondition();
	
	public ShopThread(PriorityQueue<Integer> pqi, int size) {

		this.pqi = pqi;
		MAX_SIZE = size;
		
	}
	
	@Override
	public void run() {
		
		while(true){
			
			if(Thread.currentThread().getName().endsWith("生产者")){
				producer();
			}
			
			if(Thread.currentThread().getName().endsWith("消费者")){
				consumer();
			}
		}
		
	}
	
	private void consumer(){
		
		try {
			lock.lockInterruptibly();
			while(pqi.size() == 0){
				consumer.await();
			}
			
			int item = pqi.poll();
			System.out.println(Thread.currentThread().getName()+ "消费一件商品,剩余商品" + pqi.size() + "件");
			producer.signal();
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			lock.unlock();
		}
		
	}
	
	public void producer(){
		
		try{
			lock.lockInterruptibly();
			
			while(pqi.size() == MAX_SIZE){
				producer.await();
			}
			//生产一件商品
			pqi.offer(1);
			System.out.println(Thread.currentThread().getName()+ "生产一件商品，共有商品" + pqi.size() + "件");
			consumer.signal();
		}catch (Exception e) {
			e.printStackTrace();
		}finally{
			lock.unlock();
		}
	}
    `
    
    
    
    
    
    Main.java
    
    public class Main {


	public static void main(String[] args) {
		
		
		PriorityQueue<Integer> pqi = new PriorityQueue<Integer>(10);
		ShopThread st = new ShopThread(pqi, 10);
		new Thread(st, "消费者").start();
		new Thread(st, "生产者").start();
		
	}

}


##### Lock和synchronized的选择

总结来说，Lock和synchronized有以下几点不同：

　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；

　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；

　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；

　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。

　　5）Lock可以提高多个线程进行读操作的效率。

在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况


#### BlockingQueue

  public ArrayBlockingQueue(int capacity, boolean fair) {
        if (capacity <= 0)
            throw new IllegalArgumentException();
        this.items = (E[]) new Object[capacity];
        lock = new ReentrantLock(fair);
        notEmpty = lock.newCondition();
        notFull =  lock.newCondition();
    }
    
     public void put(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();
        final E[] items = this.items;
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            try {
                while (count == items.length)
                    notFull.await();
            } catch (InterruptedException ie) {
                notFull.signal(); // propagate to non-interrupted thread
                throw ie;
            }
            insert(e);
        } finally {
            lock.unlock();
        }
    }
    
    public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            try {
                while (count == 0)
                    notEmpty.await();
            } catch (InterruptedException ie) {
                notEmpty.signal(); // propagate to non-interrupted thread
                throw ie;
            }
            E x = extract();
            return x;
        } finally {
            lock.unlock();
        }
    }

#### 线程组合未处理的异常

Java中用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，java允许对线程组控制，对线程组控制就是对一批线程控制。

在创建线程时，我们可指ThreadGroup，Thread(ThreadGroup,Runnale...);

ThreadGroup 实现了Thread.uncaughtExceptionHandler接口，可以处理未捕获的异常，那么这一批线程都有处理未捕获的异常功能。但是也可以对单个线程进行处理，只要类实该uncaughtExceptionHandler接口，如下：

public class Main implements UncaughtExceptionHandler {

	@Override
	public void uncaughtException(Thread t, Throwable e) {
		
		System.out.println("线程" + t.currentThread().getName() + "未处理异常发生了" + e);
	}
	
	public static void main(String[] aStrings){
		
		Main main = new Main();
		Thread.currentThread().setUncaughtExceptionHandler(main);
		int c =5/0;
		System.out.println(" 程序结束");
	}

}


运行结果：

线程main未处理异常发生了java.lang.ArithmeticException: / by zero


#### 使用Callable 和 Future 创建线程
Java 5开始提供了Callable 接口，该接口是Runnable的增强版，但与Runnable没有继承关系，该接口提供了一个功能强大的call方法，此方法比run方法功能更强大，它可以有返回值，也可以声明抛出异常，是一个线程执行体，但不可以调用此方法。

由于callable并没有继承runnable，所以在用Thread创建线程时，不能将callable对象当做traget传入，为此我们需要用到Future接口来关联callable与runnable，因为Future接口继承了runnable。同时Future提供了get方法返回call方法的返回值。

##### 用callable与Future创建线程的步骤如下：

1.创建实现Callable的类，并实现call()方法

2.创建实现Callable接口的实例对象，使用Futrue来包装该对象。

3.使用FutrueTask 对象作为Thread对象的traget创建启动新线程。

4. 调用Future的get的方法返回call方法的返回值。

具体使用步骤如下代码：

在MyThread.java中

    public class MyThread implements Callable<Integer> {  //@1

    	@Override
    	public Integer call() throws Exception {
		
	    	int i =0;
	    	for(; i < 20;i++){
	    		System.out.println(Thread.currentThread().getName() + ":" + i);
	    	}
	    	return i;
    	}

    }


在main.java中

    public class Main {

	public static void main(String[] args) {
		
		FutureTask<Integer> ft = new FutureTask<Integer>(new MyThread());//@2
		for(int i = 0;i < 100;i++){
			
			System.out.println(Thread.currentThread().getName() + ":" + i);
			if(i==20){
				try {
					new Thread(ft).start();//@3
				} catch (Exception e) {
					e.printStackTrace();
				}
				
			}
		}

	   	try {
			
		    	System.out.println(ft.get()); //@4  返回值
	    	} catch (Exception e) {
		    	e.printStackTrace();
	    	}
	    }

     }


#### 线程池

系统启动一个新线程，它的成本比较大，因为它涉及到与操作系统交互。特别是在需要启动大量的短暂的线程时，就应该使用线程池，线程池是在系统启动是就会创建大量的空闲的线程，程序只需要将一个Runnable对象或者Callable对象提交给线程池，那么线程池就会启动一个线程来执行它们的run方法或call方法，当run方法或者run方法执行完毕后，该线程并不会死亡，而是放回线程池，等待下个Runnable或者callable。

线程池用完后，使用shutdown方法关闭。

创建一个线程使用Executors工厂类中的静态方法，比如new前缀为名的方法。

下面是Executors工厂类包含如下几个静态工厂方法来创建线程池：

    newCachedThreadPool(); //创建一个具有缓冲功能的线程池
    
    newFixedThreadPool(int nThreads)//创建一个可重用，具有固定线程数的线程池
    
    newSingleThreadExecutor(); //创建一个只有单线程的线程池,相当于调用newFixedThreadPool(1)
    
    newScheduledThreadPool(int corePoolSize);//创建指定线程的线程池，并在指定延迟后执行任务
    
    newSingleThreadScheduledExecutor()//创建一个线程的线程池，它可以在指定延迟任务后执行线程任务

这5个静态方法中前3个返回的是一个ExecutorService对象，它代表一个线程池，它可以执行Runnable对象或者Callable对像；

后2个方法返回一个ScheduledExecutorService线程池，它是ExecutorService的子类，它可以指定延迟后执行任务。




##### 下面是使用线程池的步骤：

1.创建实现Runnable或者Callable接口的类

2. 然后就看实例....

public class MyRunnable implements Runnable {

	public void run() {
		
		for(int i = 0; i < 3;i++){
			System.out.println(Thread.currentThread().getName() + ": " + i);
		}
	}
}

public class Main {

	public static void main(String[] args) {
		
		//2.创建具有6个线程的线程池
		ExecutorService es = Executors.newFixedThreadPool(6);
		//3.向线程池中提交两个线程
		es.submit(new MyRunnable());
		es.submit(new MyRunnable());
		//4.关闭线程池
		es.shutdown();
	}
}

运行结果：

pool-1-thread-1: 0 

pool-1-thread-1: 1

pool-1-thread-1: 2

pool-1-thread-2: 0

pool-1-thread-2: 1

pool-1-thread-2: 2

### Java 7 新增的ForkJoinPool

#### java 7 为何新增ForkJoinPool呢？ForkJoinPool的功能是什么？

为充分利用多CPU，多核CPU的优势，绝不能让CPU处于空闲状态，所以就新增了ForkJoinPool。ForkJoinPool支持可以把一个任务分成多个小任务放到多个处理器核心上并行执行。多个小任务完成后，再将这些小任务结果合并起来即可。


 - ForkJoinPool是ExecutorService的实现类,它是一种特殊的线程池。它有如下两个构造函数：

    ForJoinPool(int parallelism) 创建一个包含parallelism个并行线程的ForkJoinPool
    
    ForkJoinPool() 以Runtime.getRuntime().availableProcessors()方法的返回值作为parallelism参数来创建ForkJoinPool
    
 - ForkJoinPool创建实例后，可以调用ForkJoinPool的submit(ForkJoinTask task) 或invoke(ForkJoinTask task)方法来执行指定任务.
 
ForkJoinTask 是一个抽象类，其有两个实现的类，分别是RecursiveAction和RecursiveTask,其中RecursiveTask是返回值的任务，RecursiveAction是没有返回值的任务。

#### 下面是ForkJoinTask 与 ForkJoinPool的类图

![image](http://images2015.cnblogs.com/blog/746338/201703/746338-20170320153700268-744928148.png)


下面是关于ForkJoinPool两个实例如下：

 **例1：** 分多个小任务并发打印0-299数字，执行的任务是无返回值的
 
    - PrintTask.java文件
    
    public class PrintTask extends RecursiveAction{

    	private static final long serialVersionUID = 1L;
    	//每个小任务最多打印50个数
    	private static final int MAX_SIZE = 50;
    	private int start;
    	private int end;
	
    	@Override
    	protected void compute() {
		
	    	if(end - start < MAX_SIZE){
	    		//打印数据
	    		print();
	    	}else {
	    		//把大任务分成两个小任务
			
		    	int middle = (start + end)/2;
		    	PrintTask leftTask = new PrintTask(start, middle);
		    	PrintTask rightTask = new PrintTask(middle, end);
		    	//并行执行两个小任务
		    	leftTask.fork();
		    	rightTask.fork();
		    }
		
    	}

    	private void print() {
		
    		for(int i = start; i < end;i++){
	    		System.out.println(Thread.currentThread().getName()+"打印的值i:" + i);
	    	}
		
    	}

    	//打印从start到end(不包括end)的任务
    	public PrintTask(int start, int end) {
		
	    	this.start = start;
	    	this.end = end;
    	}

    }

     - Main.java文件
     
    public class Main {

    	public static void main(String[] args) {
		
	    	ForkJoinPool pool = new ForkJoinPool();
	    	//提交待分解的大任务
	    	pool.submit(new PrintTask(0, 3000));
	    	try {
	    		pool.awaitTermination(2, TimeUnit.SECONDS);  //阻塞当前线程，直到ForkJoinPool所有任务都完成。
	    	} catch (InterruptedException e) {
			
	    		e.printStackTrace();
	    	}finally{
	    		pool.shutdown();
	    	}
	    }
    }


   **例2：** 将一个数组分成多个小任务并发累加，执行的任务是有返回值的
 
    - CalTask.java文件
    
    public class CalTask extends RecursiveTask<Integer> {

	
    	private static final long serialVersionUID = 1L;
	    private static final int MAX_SIZE = 20;
	    private int start;
	    private int end;
	    private int[]arr;
	
	    public CalTask(int start, int end, int[] arr) {
	
	    	this.start = start;
	    	this.end = end;
	    	this.arr = arr;
	    }

	    @Override
	    protected Integer compute() {
	
	    	if(end - start < MAX_SIZE){
			
	    		return calculate();
	    	}else{
	    		int middle = (start + end)/2;
	    		CalTask lefTask = new CalTask(start, middle, arr);
	    		CalTask rightTask = new CalTask(middle, end, arr);
			
	    		//并发分成两个小任务
	    		lefTask.fork();
	    		rightTask.fork();
		    	//把两个小任务的累加值合并起来
		    	return lefTask.join() + rightTask.join();
		    }
			
    	}

    	private Integer calculate() {
		
	    	int sum = 0;
	    	for(int i = start;i < end;i++ ){
	    		sum += arr[i];
	    	}
		
		    return sum;
    	}
	
    }

    - Main.java文件
    
      public class MainB {

    	public static void main(String[] args) {
		
	    	int arr[] = new int[100];
	    	for(int i= 0; i < 100;i++){
		    	arr[i] = i+1;
	    	}
		
	    	ForkJoinPool pool = new ForkJoinPool();
	    	ForkJoinTask<Integer> task = pool.submit(new CalTask(0, arr.length, arr));
	    	try {
	    		System.out.println("这个数组的总和是：" + task.get());
	    		pool.awaitTermination(2, TimeUnit.SECONDS);
			
	    	} catch (Exception e) {
	    		e.printStackTrace();
	    	}finally{
	    		pool.shutdown();
	    	}
	    }
    }
 
 ### 多线程断点下载原理
 
**多线程原理：** 抢占服务器资源

 - 单线程下载：线程从第0个字节开始下，下到最后一个字节，在本地硬盘的临时文件中从第0个字节开始写，写到最后一个字节，下载完成时，临时文件也写完了，本地就创建了一个与服务器文件一模一样的文件

 - 多线程下载：每条线程下载的开始位置和结束位置都是不一样的，每条线程下载的数据合在一起才是服务器的完整的文件

### 断点续传：

**断点续传：** 下载从上一次下载结束的位置开始

**断点续传原理：** 每次下载把下载进度保存至一个文本临时文件中，下一次下载时从文本临时文件获取上一次下载的进度，从这个进度开始继续下载

### 进度条
 计算下载百分比进度时要在long类型下计算
 
 比如我们要从服务端下载一个文件，文件大小10,我们现在开启3个线程下载，其分析过程如下图：
 
 ![image](http://images2015.cnblogs.com/blog/746338/201703/746338-20170320233956455-1775702840.png)
 
 
 其具体如下代码：
 
    public class DownLoadThread extends Thread{

	private int startIndex;
	private int endIndex;
	private int id ;
	private String path;
	private int threadCount; 
	private static int threadFinished = 0;
	
	public DownLoadThread(int startIndex, int endIndex, int id,String path,int threadCount) {
		super();
		this.startIndex = startIndex;
		this.endIndex = endIndex;
		this.id = id;
		this.path = path;
		this.threadCount = threadCount;
	}

	public void run() {
		// TODO Auto-generated method stub
		File file = new File("E:\\" + getFileNameFromPath(path));
		File progressFile = new File("E:\\" + id + ".txt");
		int lastProgress = 0;
		if(progressFile.exists()){
			try {
				FileInputStream fis = new FileInputStream(progressFile);
				BufferedReader reader = new BufferedReader(new InputStreamReader(fis));
				String text = reader.readLine();
				lastProgress = Integer.parseInt(text);
				startIndex += (lastProgress + 1);
				
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
		}
		byte[] b = new byte[1024];
		int len = 0;
		int total = lastProgress;
		try {
			URL url = new URL(path);
			HttpURLConnection conn = (HttpURLConnection) url.openConnection();
			conn.setRequestMethod("GET");
			conn.setConnectTimeout(8000);
			conn.setReadTimeout(8000);
			conn.setRequestProperty("Range", "bytes=" + startIndex + "-" + endIndex);
			if(conn.getResponseCode() == 206){
				InputStream is = conn.getInputStream();
				RandomAccessFile rdf = new RandomAccessFile(file, "rwd");
				rdf.seek(startIndex);
				while((len = is.read(b)) != -1){
					rdf.write(b,0,len);
					total += len;
					System.err.println("threadId" + id + ":" + total);
				
					FileOutputStream fos = new FileOutputStream(progressFile);
					fos.write((total+"").getBytes());
					fos.close();
				}
				rdf.close();
				System.out.println("线程" + id+ "下载完毕---------"  + total);
				
				synchronized (new Integer(threadFinished)) {
					threadFinished ++;
					if(threadFinished == threadCount){
						for (int i = 0; i < threadCount ; i++) {
							 File f = new File("E:\\" + i + ".txt");
							 f.delete();
						}
					}
					
				}
				
			}
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	private String getFileNameFromPath(String path2) {
		// TODO Auto-generated method stub
		return path2.substring(path2.lastIndexOf("/") + 1);
	}
	
    }


在main.java文件

public class Main {

	private static String path = "http://xielianwu-pc:8080/MultThreadTest/setup_10.1.0.2001q.exe";
	private static int threadCount = 4;
	private static int size;
	

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		URL url;
		try {
	
			url = new URL(path);
			HttpURLConnection conn = (HttpURLConnection) url.openConnection();
			conn.setRequestMethod("GET");
			conn.setReadTimeout(8000);
			conn.setReadTimeout(8000);
			if(conn.getResponseCode() == 200){
				int lenth = conn.getContentLength();
				System.out.println("lenth" + lenth);
				File file = new File("E:\\" + getFileNameFromPath(path));
				RandomAccessFile raf = new RandomAccessFile(file, "rwd");
				raf.setLength(lenth);
				raf.close();
				size = lenth / threadCount;
				for(int id = 0; id < threadCount; id++){
					int startIndex = id * size;
					int endIndex = (id + 1) * size - 1;
					if(id == threadCount - 1)
						endIndex = lenth - 1;
					System.out.println("线程" + id +"  " + startIndex + "~" + endIndex);
					new DownLoadThread(startIndex, endIndex, id,path,threadCount).start();
				}
			}
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	
	}

	private static String getFileNameFromPath(String path){
		return path.substring(path.lastIndexOf("/") + 1);
		
	}

}


 ### 包装线程不安全的集合
 
 Java集合中ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap等都是线程不安全的，当多个线程并发访问这些集合时，我们可以使用Collections提供的静态方法把这些集合包装成线程安全的集合。Collections提供了如下几个静态方法 ：
 
 	    Collections.synchronizedCollection(arg0)// 返回线程安全的collection
 	    
		Collections.synchronizedList(arg0)  //返回线程安全的List对象
		
		Collections.synchronizedMap(arg0) //返回线程安全的Map对象
		
		Collections.synchronizedSet(arg0) //返回线程安全的Set对象
		Collections.synchronizedSortedMap(arg0) //返回线程安全的SortedMap对象
		Collections.synchronizedSortedSet(arg0) // //返回线程安全的SortedSet对象
 
 
 例如，我们需要在多线程中使用安全的HashMap对象，则可以如下代码：
    
    HashMap m = Collections.synchronizedMap(new HashMap());
    
**注意：** 如果需要把某个集合包装线程安全的集合，应该在创建之后立即包装，如上程序所示，当HashMap对象创建后立即被包装成线程安全的HashMap对象。

### 线程安全类的集合类

从Java 5.0开始，在java.util.concurrent包下提供了大量支持高效并发访问的集合接口和实现类，如下图：

![image](http://images2015.cnblogs.com/blog/746338/201703/746338-20170320233938705-1850691489.png)


## IO流

#### 字节流和字符流

 - 字节流与字符流操作的数据单元不同：字节了流操作的数据单元是8位的字节，而字符流操作的数据单元是16位的字符。
 
 - 字节流主要由InputStream和OutputStream作为基类，而字符流则主要由Reader和Writer作为基类。


#### InputStream 类型与 Reader类型

InputStream和Reade是所有输入流的抽象基类，不能创建实例来执行输入，但是InputStream和Reader是所有输入流的模块，它的方法是所有流可以使用的。

###### 下面介绍InputStream里的关于read的三个方法：

**1.** int read(); 从输入流中读取单个字节，返回所读取的字节数。

**2.** int read(byte[] b);从输入流中最多读取b.length个字节的数据，并将存储在数组b中，返回实际所读取的字节数。

**3.** int read(byte[] b，int  off, int  len);从输入流中最多读取len个字节的数据，并将存储在数组b中,放入数组b中时，并不是从数组起点开始，而是从off位置开始，返回实际所读取的字节数。

###### 下面介绍Reader里的关于read的三个方法：

**1.** int read(); 从输入流中读取单个字符，返回所读取的字符数。

**2.** int read(char[] cbuf);从输入流中最多读取cbuf.length个字符的数据，并将存储在数组cbuf中，返回实际所读取的字符数。

**3.** int read(char[] cbuf，int  off, int  len);从输入流中最多读取len个字符的数据，并将存储在数组cbuf中,放入数组cbuf中时，并不是从数组起点开始，而是从off位置开始，返回实际所读取的字符数。

**注意**：当read的方法返回-1时，表示流读取完毕。

##### FileInputStream类型 和 FileReader类型

正如前面所叙述的InputStream和Reader是抽象类，不能创建实例，但它们分别有一个用于读取文件的输入流：FileInputStream和FileReader,它们都是节点流，会直接和指定文件关联。下面是分别看下FileInputStream和FileReader的程序例子。

FileInputStream的例：

public class Main {

	public static void main(String[] args) {
	
		byte[] b = new byte[1024];
		FileInputStream fis = null;
		try {
		      //创建字节出入流
		    fis = new FileInputStream("C:\\Users\\xielianwu\\Desktop\\test.txt"); \\"\""反斜杆用于转义字符
			while( (fis.read(b)) > -1){ //判断文件是否读完毕
				
				System.out.println(new String(b));
			}
		} catch (IOException e) {
			
			e.printStackTrace();
		}finally{
			try {
				if(fis != null)
				fis.close();
			} catch (IOException e) {
			
				e.printStackTrace();
			}
		}
	}
}

FileReader的例：

public class Main2 {

	public static void main(String[] args) {
			
		FileReader fr = null;
			try {
				//创建字符输入流
				 fr = new FileReader("C:\\Users\\xielianwu\\Desktop\\test.txt");
				char[] cbuf = new char[32];
				int len =0;
				while((len = fr.read(cbuf)) > 0){
					System.out.println(new String(cbuf));
				}
			} catch (Exception e) {
				e.printStackTrace();
			}finally{
				try {
					if(fr != null)
						fr.close();
				} catch (Exception e2) {

						e2.printStackTrace();
				}
				
			}
	}
}


#### OutputStream 类型和 Writer类型

OutputStream和Writer是所有输出流的抽象基类，不能创建实例来执行输出，但是OutputStream和Writer是所有输出流的模块，它的方法是所有流可以使用的。

###### 这两个流都有关于write的三个方法。

**1.** void write(int c) 将指定的字节/字符输出到输出流中，c即可以代表字节，也可以代表字符。

**2.** void write(byte[]/char[] buf) 将字节数组/字符数组的数据输出到指定的输出流中。

**3.** void write(byte[]/char[] buf,int off,int len) 将字节数组/字符数组中从off位置开始，长度为len的字节/字符输出到输出流中。

Writer类型是输出字符为单位，Writer可以用字符串代替字符数组，所以Writer有两个额外的write方法，如下：

**1.** void Write(String str) 将str字符串里包含的字符输出到指定输出流中。

**3.** void write(String str,int off,int len) 将str 字符串里从off位置开始，长度为len的字符输出到输出到指定输出流中。

##### FileOutputStream类型 和 FileWriter类型

OutputStream和Writer是抽象类，不能创建实例，但它们分别有一个用于写入文件的输出流：FileOutputStream和FileWriter,它们都是节点流，会直接和指定文件关联。下面是分别看下FileOutputStream和FileWriter的程序例子。

FileOutputStream例：

public class Main {
	
	public static void main(String[] args) {
	
		FileInputStream fis = null;
		FileOutputStream fos = null;

		try {
			   //创建字节输入流
			 fis = new FileInputStream("C:\\Users\\xielianwu\\Desktop\\test.txt");
			 //创建字节输出流
			 fos = new FileOutputStream("C:\\Users\\xielianwu\\Desktop\\test2.txt");
			 byte[] b = new byte[32];
			 int len = 0;
			while(( len = fis.read(b )) > 0){
				 //每次读取一次，即写入文件输出流，读多少，写多少
				 fos.write(b, 0, len);
			 }
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {
				
				if(fis != null)
					fis.close();
				if(fos != null)
					fos.close();
			} catch (Exception e2) {
				e2.printStackTrace();
			}
		}
	}
}

注意：用FileOutputStream对象创建对象时，若指定目录下没有相关文件，就会自动创建字符串命名的文件。例如，test2.txt自动帮我们创建了。

FileWriter例：

public class Main2 {

	public static void main(String[] args) {
		
		FileWriter fw =null;
		try {
			fw = new FileWriter("C:\\Users\\xielianwu\\Desktop\\test3.txt");
			fw.write("金色\r\n");
			fw.write("股言与落霞几飞\r\n");
			fw.write("秋水共长天一色\r\n");
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {
				
				if(fw != null)
					fw.close();
			} catch (Exception e2) {
				
			}	
		}
	}

}

注意：用FileWriter对象创建对象时，若指定目录下没有相关文件，就会自动创建字符串命名的文件。例如，test2.txt自动帮我们创建了


### 转换流

输入/输出流体系还提供了两个转换流,这两个转换流用于实现将字节流转换成字符流,其中InputStreamReader将字节输入流转换成字符输入流，OutputStreamWriter将字节输出流转换成字符输出流。



#### 对象序列化

如果需要将某个对象保存到磁盘上或通过网络传输，那么这个类应该实现Serializable接口或者实现Externalizable接口之一，这一过程就是序列化对象。

一旦某个类实现了Serializable接口，该类的对象就是可序列化的，程序可以通过两个步骤来序列化对象，如下所示：

（1） 创建一个ObjectOutputStream输出流,这个输出流是一个处理流，所以必须建立在其他节点流的基础上，其代码如下所示：

ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("object.txt");

(2) 调用ObjectOutputStream对象的writeObject()方法输出可以序列化对象，如下代码：

//将一个Person对象输出到输出流中。 

oos.writeObject(per);

具体代码看下面的例子：

public class Person implements Serializable {

	private String name;
	private int age;
	public Person(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	public String toString() {
		return "Person [name=" + name + ", age=" + age + "]";
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
}


public class Main {
	
	public static void main(String[] args) {
	
		try {
			
			ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("object.txt"));
			Person per = new Person("张三", 18);
			oos.writeObject(per);
		} catch (Exception e) {
		
			e.printStackTrace();
		}
	}
}

运行：

分析面的Person的类实现了Serializable接口，该类的对象是可序列化的，此时创建ObjectOutputStream对象将Person对象序列化到文件中。若下希望从二进制流中恢复Java对象，我们需要反序列化。反序列化的步骤如下：

（1） 创建一个ObjectInputStream输入流,这个输入流是一个处理流，所以必须建立在其他节点流的基础上，其代码如下所示：

ObjectInputStream ois = new ObjectInputStream(new FileInputStream("object.txt");

(2) 调用ObjectInputStream对象的readObject()方法输出可以序列化对象，如下代码：

//将一个Person对象输出到输出流中。

ois.readObject();

下面程序示范从刚刚生动的object.txt文件读取Person对象步骤，例子如下：

public class Main2 {

	public static void main(String[] args) {
		try {
			//创建一个ObjectInputStream输入流
			ObjectInputStream ois = new ObjectInputStream(new FileInputStream("object.txt"));
			//从输入流读取一个Java对象，并将其强制转换Person对象。
			Person per = (Person) ois.readObject();
			System.out.println(per);
			
		} catch (Exception e) {
		
			e.printStackTrace();
		}
	}
}

运行结果：

Person [name=张三, age=18]

分析：上面的程序创建一个ObjectInputStream输入流对象，并使用这个对象调用readObject方法读取文件中的Java对象，这就是反序列化过程。

**注意**：反序列化是读取的是Java对象不是java类，因此采用反序列化恢复Java对象时，必须提供java对象所属类的class文件，否则会引发ClassNotFoundException异常。

##### 对象引用的序列化的序列化

前面介绍PerSon类的两个Field分别是String类型和int类型，如果类的Filed类型不是基本类型或String类型时，是一个引用类型，那么这个引用类必须可序列化的，否则拥有该Field的引用类型的类是不可序列化的。

下面我们用一个例子引入场景，假设我们有两个teacher对象，他们的Student实例变量都是引用到同一个person对象，而且该Person对象还有一个引用变量引用它。代码如下：

Person person = new Person("孙悟空", 500);

Teacher t1 = new Teacher("唐僧", person

Teacher t2 = new Teacher("菩提祖师", person);

那么这三个变量在内存中的存储如下图：

![image](	http://images2015.cnblogs.com/blog/746338/201703/746338-20170306102539344-2125827765.png)

那么程序在序列化Teacher对象时，它会将Teacher对象所包含的person引用一并序列化，那么我们在分别序列化t1,t2和person对象时，系统会不会将person对象序列三次到输出流呢？即输出流有三个person对象。当我们从输出反序列化流读取t1,t2和person Java对象时，那么t1,t2所拥有的person引用不是同一个引用。答案是不会的，下面来看下序列化t1,t2和person对象后在内存中的变化，如下图：

![image](http://images2015.cnblogs.com/blog/746338/201703/746338-20170306104107609-1452951202.png)

所以,java序列化机制采用了一种特殊的序列化算法，起算内容如下：

1.所有保存到磁盘中的对象都有一个序列化编号号。

2.当程序序列化一个对象时，程序将首先检查该对象是不是被序列化了，只有该对象未被序列化时，系统才会将对象转换成字节序列并输出。

3.若某个对象已经被序列化，程序将只直接输出一个序列化编号，而不是对象。

所以根据上面的序列化算法，输出流只只有一个person对象。当序列化对象t2和person对象时，只向输出流输出person对象的序列化编号。

下面是具体代码示例:

public class Teacher implements Serializable {

	private String name;
	private Person student;
	public Teacher(String name, Person student) {
		
		this.name = name;
		this.student = student;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Person getStudent() {
		return student;
	}
	public void setStudent(Person student) {
		this.student = student;
	}
	public String toString() {
		return "Teacher [name=" + name + ", student=" + student + "]";
	}
}


public class Main3 {

	public static void main(String[] args) {
		
		try {
			ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("teacher.txt"));
			Person person = new Person("孙悟空", 500);
			Teacher t1 = new Teacher("唐僧", person);
			Teacher t2 = new Teacher("菩提祖师", person);
			//依次将4个对象写入输出流
			oos.writeObject(t1);
			oos.writeObject(t2);
			oos.writeObject(person);
			oos.writeObject(t2);
		} catch (Exception e) {
			e.printStackTrace();
		}	
	}
}


编译运行

下面是反序化从输出文件中读取对象，如下例：

public class Main4 {

	public static void main(String[] args) {
		
		try {
			
			ObjectInputStream ois = new ObjectInputStream(new FileInputStream("teacher.txt"));
			Teacher t1 = (Teacher) ois.readObject();
			Teacher t2 = (Teacher) ois.readObject();
			Person p = (Person) ois.readObject();
			Teacher t3 = (Teacher) ois.readObject();
			
			System.out.println(t1);
			System.out.println(t2);
			System.out.println(t3);
			
			System.out.println("t1的student引用是否是和p相同：" + (t1.getStudent() == p));
			
			System.out.println("t2的student引用是否是和p相同：" + (t2.getStudent() == p));
			
			System.out.println("t2和t3是否是同一个对象：" + (t2 == t3));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}


运行结果：

Teacher [name=唐僧, student=Person [name=孙悟空, age=500]]
Teacher [name=菩提祖师, student=Person [name=孙悟空, age=500]]
Teacher [name=菩提祖师, student=Person [name=孙悟空, age=500]]
t1的student引用是否是和p相同：true
t2的student引用是否是和p相同：true
t1和tt2是否是同一个对象：true

分析：t1,t2,person都序列化的文件中，t1和t2的student引用都是同一个person引用，i即文件中只有一个person对象。即序列化引用遵循序列化算法。

